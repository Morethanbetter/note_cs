# 问题

### 为什么业务代码中少见多线程？

因为并发编程的核心是写==线程安全的类==，对==共享可变数据==的==操作==进行==封装==，而且这种封装只在单进程中有效，即==并发编程只在单进程有意义==。

而业务代码中，共享可变数据是存储在DB中的，从DB中查询到的应用中的只是副本，并且分布式环境中，对共享可变数据的操作进行封装是没意义的，因为单一一台服务器中做了线程安全，对于集群环境是不起作用的。

对于业务开发来说，多线程一般主要是分工和协同或者跑批用。

# 并发编程的三大核心问题

分工、协作（同步）和互斥

## 分工

所谓分工，类似于现实中一个组织完成一个项目，项目经理要拆分任务，安排合适的成员去完成。

在并发编程领域，==你==就是==项目经理==，==线程==就是==项目组成员==。任务分解和分工对于项目成败非常关键，不过在并发领域里，==分工更重要，它直接决定了并发程序的性能==。

在现实世界里，分工是很复杂的，著名数学家华罗庚曾用“烧水泡茶”的例子通俗地讲解了统筹方法（一种安排工作进程的数学方法），“烧水泡茶”这么简单的事情都这么多说道，更何况是并发编程里的工程问题呢。

学习分工，最佳的方式就是和现实世界做对比。

## 协作（同步）

好工之后，就是具体执行了。在项目执行过程中，==任务之间是有依赖的==，一个任务结束后，依赖它的后续任务就可以开工了，后续工作怎么知道可以开工了呢？这个就是靠==沟通协作==了，这是一项很重要的工作。

在并发编程领域里的**同步**，主要指的就是**线程间的协作**，本质上和现实生活中的协作没区别，不过是==一个线程执行完了一个任务，如何通知执行后续任务的线程开工==而已。

工作中遇到的线程协作问题，基本上都可以描述为这样的一个问题：==当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行==。

## 互斥

分工、同步主要强调的是==性能==，但并发程序里还有一部分是关于==正确性==的，用专业术语叫“==线程安全==”。

并发程序里，当多个线程同时访问同一个==共享变量==的时候，结果是不确定的。导致不确定的主要源头是==可见性==问题、==有序性==问题和==原子性==问题。

为了解决这三个问题，Java 语言引入了==内存模型==，来避免可见性问题、有序性问题，但是还不能完全解决线程安全问题。解决线程安全问题的==核心方案==还是==互斥==。

所谓互斥，指的是==同一时刻==，只允许一个线程==访问共享变量==（或者说：操作（读写）共享数据）。

实现互斥的==核心技术==就是==锁==。





